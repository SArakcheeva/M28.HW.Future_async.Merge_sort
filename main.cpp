/* Алгоритм сортировки слиянием:
    Шаг 1: Разбиваем входящий массив на два.
    Шаг 2: Выполняем рекурсивный вызов для этих двух частей, передавая часть массива и индекс его начала и конца. Вызовы происходят пока индекс начала не станет больше или равен индексу конца.
    Шаг 3: Выполняется обратный процесс соединения всех частей в один массив. 
*/

#include <future>
#include <chrono>
#include <iostream>
#include <random>

using namespace std;

bool make_thread = true; // флаг - для сравнения скорости работы многопоточной и обычной сортировок
                         // (для указания функции запускать вычисления в потоке или нет)

unsigned int thread_count; // максимально допустимое число одновременно выполняемых потоков.


// соединение всех частей в один массив
void merge(int* arr, int l, int m, int r)
{
    int nl = m - l + 1;
    int nr = r - m;

    // создаем временные массивы
    std::vector<int> left(nl);
    std::vector<int> right(nr);

    // копируем данные во временные массивы
    for (int i = 0; i < nl; i++)
        left[i] = arr[l + i];
    for (int j = 0; j < nr; j++)
        right[j] = arr[m + 1 + j];

    int i = 0, j = 0;
    int k = l;  // начало левой части

    while (i < nl && j < nr) {
        // записываем минимальные элементы обратно во входной массив
        if (left[i] <= right[j]) {
            arr[k] = left[i];
            i++;
        }
        else {
            arr[k] = right[j];
            j++;
        }
        k++;
    }
    // записываем оставшиеся элементы левой части
    while (i < nl) {
        arr[k] = left[i];
        i++;
        k++;
    }
    // записываем оставшиеся элементы правой части
    while (j < nr) {
        arr[k] = right[j];
        j++;
        k++;
    }
}


// Поскольку мы используем рекурсию, нужно определить точку останова. 
// В нашем случае, это будет условие, когда левая граница достигнет правой или превысит ее значение.
// В функцию мы передаем начало и конец массива, поэтому нам нужно вычислять каждый рекурсивный вызов,
// где будет находиться середина массива, по которой происходит разделение. 
// Далее снова вызываем нашу сортировку от полученных двух частей. 
// После того как выполнится последний вызов для второй части начнется
// процесс соединения всех частей в один массив с помощью функции merge.
//     int* arr - сортируемый массив
//     int left - начало сортируемой части
//     int right - конец сортируемой части
unsigned int tN = 1;// счетчик потоков
void mergeSort(int* arr, int left, int right)
{
    if (left >= right)
        return;

    tN++;

    int middle = (left + right - 1) / 2; // середина массива

    // 1. Если элементов в сортируемой части больше чем 10000, вызываем асинхронно рекурсию для левой части
    // 2. Также вводим ограничение на количество одновременно выполняемых потоков, т.к. 
    // когда количество потоков превышает количество доступных ядер процессора,
    // то начинается конкуренция за ресурсы, что приводит к снижению производительности программы в целом.
    // + создание слишком большого количества потоков может привести к проблемам с управлением памятью
    if (make_thread && (tN < thread_count) && (right - left > 10000)) {
        future<void> f = async(launch::async, [&]() {   // в лямбда-функции захватываем всё по ссылке
            mergeSort(arr, left, middle);    // лямбда-функция, которая вызывает функцию сортировки левой части, чтобы разбить потоки
            });
        mergeSort(arr, middle + 1, right);
        // соединение всех частей в один массив
        merge(arr, left, middle, right);

        // здесь будет вызван деструктор ~f, т.о. поток заблокирует основной поток до завершения выполнения данной функции
        // эта функция потока также вызовет в свою очередь mergeSort, создаст новый поток и т.д.
        // и чтобы ограничить создание множества таких потоков мы и вводим доп.условие на ограничение

    }
    else {
        // запускаем обе части синхронно
        mergeSort(arr, left, middle);
        mergeSort(arr, middle + 1, right);
        merge(arr, left, middle, right);
    }
}


int main()
{
    // максимально допустимое число одновременно выполняемых потоков.
    // Если значение не определено или не поддаётся вычислению, возвращается ​0​
    thread_count = std::thread::hardware_concurrency();
    if (thread_count == 0)
        thread_count = 2;
    std::cout << thread_count << " concurrent threads are supported.\n";

    // сгенерируем массив целых чисел
    srand(0);
    long arr_size = 10000000;
    int* array = new int[arr_size];
    if (array == nullptr) return 0;

    for (long i = 0; i < arr_size; i++) {
        array[i] = rand() % 500000;
    }

    time_t start, end;

    // запускаем сортировку в многопоточном варианте
    // многопоточный запуск
    time(&start);
    mergeSort(array, 0, arr_size - 1);
    time(&end);
    // и выводим время, за которое она была выполнена
    double seconds = difftime(end, start);
    printf("The time with future/async: %f seconds\n", seconds);

    for (long i = 0; i < arr_size - 1; i++) {
        if (array[i] > array[i + 1]) {
            cout << "Unsorted" << endl;
            break;
        }
    }

    // сгенерируем массив целых чисел для однопоточного варианта
    for (long i = 0; i < arr_size; i++) {
        array[i] = rand() % 500000;
    }
    // однопоточный запуск сортировки
    make_thread = false;// маркер, что выполнять сортировку в одном потоке
    time(&start);
    mergeSort(array, 0, arr_size - 1);
    time(&end);
    seconds = difftime(end, start);
    printf("The time 1 thread: %f seconds\n", seconds);

    delete[] array;

    return 0;
}